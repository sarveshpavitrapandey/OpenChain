
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title DOIRegistry
 * @dev Contract for managing Digital Object Identifiers (DOIs) for scientific papers
 */
contract DOIRegistry is AccessControl {
    using Counters for Counters.Counter;
    
    bytes32 public constant REGISTRAR_ROLE = keccak256("REGISTRAR_ROLE");
    Counters.Counter private _doiCounter;
    
    // Prefix for all DOIs generated by this registry
    string public doiPrefix = "10.5281/";
    
    struct DOIRecord {
        string doi;
        uint256 paperId;
        address author;
        string title;
        uint256 timestamp;
        bool isActive;
    }
    
    // Mapping from DOI string to DOIRecord
    mapping(string => DOIRecord) private _doiRecords;
    
    // Mapping from paper ID to DOI
    mapping(uint256 => string) private _paperToDoi;
    
    // Events
    event DOIRegistered(string doi, uint256 indexed paperId, address indexed author);
    event DOIDeactivated(string doi, uint256 indexed paperId);
    event DOIReactivated(string doi, uint256 indexed paperId);
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(REGISTRAR_ROLE, msg.sender);
    }
    
    /**
     * @dev Register a new DOI for a paper
     * @param _paperId The ID of the paper in the PaperSubmission contract
     * @param _author The address of the paper's author
     * @param _title The title of the paper
     * @return The newly registered DOI string
     */
    function registerDOI(uint256 _paperId, address _author, string memory _title) 
        public 
        onlyRole(REGISTRAR_ROLE) 
        returns (string memory) 
    {
        require(bytes(_title).length > 0, "Title cannot be empty");
        require(_paperToDoi[_paperId].length == 0, "DOI already exists for this paper");
        
        _doiCounter.increment();
        uint256 doiNumber = _doiCounter.current();
        
        // Generate DOI string: prefix + zerion. + counter (e.g., 10.5281/zerion.1234)
        string memory doiString = string(abi.encodePacked(doiPrefix, "zerion.", _uintToString(doiNumber)));
        
        DOIRecord memory newRecord = DOIRecord({
            doi: doiString,
            paperId: _paperId,
            author: _author,
            title: _title,
            timestamp: block.timestamp,
            isActive: true
        });
        
        _doiRecords[doiString] = newRecord;
        _paperToDoi[_paperId] = doiString;
        
        emit DOIRegistered(doiString, _paperId, _author);
        
        return doiString;
    }
    
    /**
     * @dev Get a DOIRecord by DOI string
     * @param _doi The DOI string to look up
     * @return The DOIRecord struct containing the DOI's details
     */
    function getDOIRecord(string memory _doi) 
        public 
        view 
        returns (DOIRecord memory) 
    {
        require(bytes(_doiRecords[_doi].doi).length > 0, "DOI does not exist");
        return _doiRecords[_doi];
    }
    
    /**
     * @dev Get a DOI by paper ID
     * @param _paperId The ID of the paper
     * @return The DOI string for the given paper ID
     */
    function getDOIByPaperId(uint256 _paperId) 
        public 
        view 
        returns (string memory) 
    {
        string memory doi = _paperToDoi[_paperId];
        require(bytes(doi).length > 0, "No DOI found for this paper ID");
        return doi;
    }
    
    /**
     * @dev Deactivate a DOI (e.g., for retracted papers)
     * @param _doi The DOI to deactivate
     */
    function deactivateDOI(string memory _doi) 
        public 
        onlyRole(REGISTRAR_ROLE) 
    {
        require(bytes(_doiRecords[_doi].doi).length > 0, "DOI does not exist");
        require(_doiRecords[_doi].isActive, "DOI is already inactive");
        
        _doiRecords[_doi].isActive = false;
        
        emit DOIDeactivated(_doi, _doiRecords[_doi].paperId);
    }
    
    /**
     * @dev Reactivate a previously deactivated DOI
     * @param _doi The DOI to reactivate
     */
    function reactivateDOI(string memory _doi) 
        public 
        onlyRole(REGISTRAR_ROLE) 
    {
        require(bytes(_doiRecords[_doi].doi).length > 0, "DOI does not exist");
        require(!_doiRecords[_doi].isActive, "DOI is already active");
        
        _doiRecords[_doi].isActive = true;
        
        emit DOIReactivated(_doi, _doiRecords[_doi].paperId);
    }
    
    /**
     * @dev Check if a DOI exists and is active
     * @param _doi The DOI to check
     * @return bool True if the DOI exists and is active
     */
    function isValidDOI(string memory _doi) 
        public 
        view 
        returns (bool) 
    {
        return bytes(_doiRecords[_doi].doi).length > 0 && _doiRecords[_doi].isActive;
    }
    
    /**
     * @dev Set a new DOI prefix
     * @param _newPrefix The new DOI prefix to use
     */
    function setDOIPrefix(string memory _newPrefix) 
        public 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        doiPrefix = _newPrefix;
    }
    
    /**
     * @dev Helper to convert a uint to a string
     * @param _value The uint to convert
     * @return String representation of the uint
     */
    function _uintToString(uint256 _value) 
        internal 
        pure 
        returns (string memory) 
    {
        if (_value == 0) {
            return "0";
        }
        
        uint256 temp = _value;
        uint256 digits;
        
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        
        while (_value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint8(_value % 10)));
            _value /= 10;
        }
        
        return string(buffer);
    }
}
